<!DOCTYPE html>
<html>
<head>
    <title>Mi Visualizador Geoespacial</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://unpkg.com/leaflet-geometryutil@latest/src/leaflet.geometryutil.js"></script>
    <script src="https://unpkg.com/leaflet-image@0.4.0/leaflet-image.js"></script> 

    <script src="https://unpkg.com/shpjs@latest/dist/shp.js"></script>
    <script src="https://unpkg.com/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script> 
    
    <style>
        html, body, #map { height: 100%; width: 100%; margin: 0; padding: 0; background-color: #f0f0f0; }
        .leaflet-bar.custom-control { background-color: white; padding: 8px 12px; border: 2px solid rgba(0,0,0,0.2); border-radius: 4px; cursor: pointer; font: 14px "Helvetica Neue", Arial, Helvetica, sans-serif; box-shadow: 0 1px 5px rgba(0,0,0,0.65); }
        .info { padding: 6px 8px; font: 14px/16px Arial, Helvetica, sans-serif; background: white; background: rgba(255,255,255,0.8); box-shadow: 0 0 15px rgba(0,0,0,0.2); border-radius: 5px; max-height: 45vh; overflow-y: auto; }
        .info h4 { margin: 0 0 5px; color: #777; cursor: pointer; user-select: none; }
        .info h4::after { content: ' ▼'; font-size: 10px; float: right; }
        .info.collapsed h4::after { content: ' ►'; }
        .info.collapsed { max-height: 40px; overflow: hidden; }
        .legend { text-align: left; line-height: 18px; color: #555; max-height: 300px; overflow-y: auto; }
        .legend i { width: 18px; height: 18px; float: left; margin-right: 8px; opacity: 0.9; }
        .info select, .info input { margin-bottom: 5px; width: 100%; box-sizing: border-box; }
        .info label { display: block; margin-top: 5px; font-weight: bold; color: #555; font-size: 12px; }
        .config-options { border-top: 1px solid #ddd; margin-top: 5px; padding-top: 5px; }
        .color-picker-container { display: flex; align-items: center; justify-content: space-between; }
        .color-picker-container input[type="color"] { width: 80px; height: 25px; padding: 0 2px; }
        .layer-list { list-style: none; padding: 0; margin: 0 0 10px 0; }
        .layer-list li { background-color: #fff; border: 1px solid #ddd; padding: 8px; margin-bottom: -1px; font-size: 13px; cursor: pointer; user-select: none; }
        .layer-list li:hover { background-color: #f4f4f4; }
        .layer-list li.active { font-weight: bold; background-color: #d4f2ff; border-left: 3px solid #0096d2; padding-left: 6px; }
        .layer-list li.sortable-ghost { background: #c8ebfb; }
        .hide-for-export { display: none !important; }
        .loading-indicator {
            position: absolute; 
            top: 10px; 
            right: 10px; 
            background: rgba(255,255,255,0.8); 
            padding: 5px 10px; 
            border-radius: 5px; 
            z-index: 1000;
            font-size: 14px;
            color: #333;
            box-shadow: 0 1px 5px rgba(0,0,0,0.65);
        }
    </style>
</head>
<body>

<div id="map"></div>

<script>
    const map = L.map('map', { attributionControl: false, preferCanvas: true }).setView([24.5, -99.5], 5); 
    const infoControl = L.control();
    const legendControl = L.control({position: 'bottomright'});
    let currentActiveLayer = null;
    let orderedLayers = [];
    let sortableInstance = null;
    
    // Nueva variable para el historial de elementos dibujados
    let drawnItemsHistory = []; 

    const oceanBasemap = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}', { attribution: 'Esri' });
    const streets = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'OpenStreetMap' });
    const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Esri' });
    const light = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{y}/{x}{r}.png', { attribution: 'CARTO' });
    const baseMaps = { "Océano": oceanBasemap, "Calles": streets, "Satélite": satellite, "Claro": light };
    const layerControl = L.control.layers(baseMaps, {}, { collapsed: true }).addTo(map);
    oceanBasemap.addTo(map);
    L.control.attribution({ position: 'bottomleft', prefix: false }).addTo(map);
    
    const sequentialPalettes = { 'YlOrRd': ['#FFFFE5','#FFF7BC','#FEE391','#FEC44F','#FE9929','#EC7014','#CC4C02','#993404','#662506','#4C1B03'], 'Blues': ['#F7FBFF','#E3EEF9','#CFE1F2','#B5D4E9','#AC7E1','#7FB9D9','#64ABD1','#4BA0C9','#3294C1','#0884B9'], 'Greens': ['#F7F7F7','#E5F5E0','#C7E9C0','#A1D99B','#74C476','#41AB5D','#238B45','#006D2C','#00441B','#002B12'], 'Reds': ['#FFF5F0','#FEE0D2','#FCBBA1','#FC9272','#FB6A4A','#EF3B2C','#CB181D','#A50F15','#67000D','#4A0008'] };
    const categoricalPalettes = { 'Paired': ['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99','#b15928'], 'Accent': ['#7fc97f','#beaed4','#fdc086','#ffff99','#386cb0','#f0027f','#bf5b17','#666666'], 'Set1': ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf'] };

    // --- FUNCIONES Y CONTROLES ---
    function getColor(value, grades, paletteName) { if (value === undefined || value === null) return '#CCCCCC'; const palette = sequentialPalettes[paletteName]; for (let i = grades.length - 2; i >= 0; i--) { if (value > grades[i]) { return palette[i % palette.length]; } } if (value === grades[0]) return palette[0]; return '#CCCCCC'; }
    function updateVisualization(layer) { if (!layer) return; const config = layer.options.config; if (config.displayMode === 'simple') { let simpleStyle = { weight: 2, color: config.simpleOutlineColor, fillColor: config.simpleFillColor }; switch(config.simpleRenderMode) { case 'both': simpleStyle.stroke = true; simpleStyle.fill = true; simpleStyle.fillOpacity = 0.6; break; case 'fill': simpleStyle.stroke = false; simpleStyle.fill = true; simpleStyle.fillOpacity = 0.6; break; case 'outline': simpleStyle.stroke = true; simpleStyle.fill = false; break; } layer.setStyle(simpleStyle); if (layer === currentActiveLayer) legendControl.update(null); return; } if (config.displayMode === 'classified') { const values = layer.toGeoJSON().features.map(f => f.properties[config.activeVariable]).filter(v => v !== null && typeof v === 'number' && isFinite(v)); const uniqueValues = [...new Set(values)]; if (uniqueValues.length < 2) { config.numericStats[config.activeVariable].grades = []; } else { const classCount = Math.min(uniqueValues.length, config.numClasses, sequentialPalettes[config.activePalette].length); config.numericStats[config.activeVariable].grades = ss.jenks(values, classCount); } } if (config.displayMode === 'categorical') { const values = layer.toGeoJSON().features.map(f => f.properties[config.activeCategoricalVariable]); const uniqueValues = [...new Set(values)].sort(); config.categoricalMap = {}; const palette = categoricalPalettes[config.activeCategoricalPalette]; uniqueValues.forEach((value, index) => { config.categoricalMap[value] = palette[index % palette.length]; }); } layer.setStyle(function(feature) { const currentConfig = this.options.config; if (currentConfig.displayMode === 'classified') { const value = feature.properties[currentConfig.activeVariable]; const grades = currentConfig.numericStats[currentConfig.activeVariable].grades; return { fillColor: getColor(value, grades, currentConfig.activePalette), weight: 1, opacity: 1, color: 'white', fillOpacity: 0.8 }; } if (currentConfig.displayMode === 'categorical') { const value = feature.properties[currentConfig.activeCategoricalVariable]; const color = currentConfig.categoricalMap[value] || '#CCCCCC'; return { fillColor: color, weight: 1, opacity: 1, color: 'white', fillOpacity: 0.8 }; } }.bind({options: {config: layer.options.config}})); if (layer === currentActiveLayer) { legendControl.update(layer); } }
    function processData(geojson, name) { const numericProperties = [], stringProperties = [], numericStats = {}; if (geojson.features && geojson.features.length > 0) { const firstProps = geojson.features[0].properties; for (const key in firstProps) { if (typeof firstProps[key] === 'number') { numericProperties.push(key); numericStats[key] = {}; } else if (typeof firstProps[key] === 'string') { stringProperties.push(key); } } } const defaultMode = numericProperties.length > 0 ? 'classified' : (stringProperties.length > 0 ? 'categorical' : 'simple'); const layerConfig = { name, numericProperties, stringProperties, numericStats, activeVariable: numericProperties[0] || null, activeCategoricalVariable: stringProperties[0] || null, numClasses: 7, activePalette: 'YlOrRd', activeCategoricalPalette: 'Paired', displayMode: defaultMode, simpleRenderMode: 'both', simpleFillColor: '#3388ff', simpleOutlineColor: '#ffffff' }; const newLayer = L.geoJSON(geojson, { config: layerConfig, style: { color: "#3388ff", weight: 2, fillOpacity: 0.6 } }).addTo(map); newLayer.eachLayer(layer => { let popupContent = '<table>'; for (const key in layer.feature.properties) { popupContent += `<tr><td><strong>${key}</strong></td><td>${layer.feature.properties[key]}</td></tr>`; } popupContent += '</table>'; layer.bindPopup(popupContent, { maxHeight: 200, minWidth: 200 }); }); layerControl.addOverlay(newLayer, name); orderedLayers.unshift(newLayer); currentActiveLayer = newLayer; infoControl.update(); updateVisualization(currentActiveLayer); applyLayerOrder(); }
    infoControl.onAdd = function (map) { this._div = L.DomUtil.create('div', 'info'); L.DomEvent.disableClickPropagation(this._div); L.DomEvent.on(this._div, 'click', function(e) { if (e.target.tagName === 'H4') { this._div.classList.toggle('collapsed'); } }, this); this.update(); return this._div; };
    infoControl.update = function () { let htmlContent = '<h4>Configuración</h4>'; if (orderedLayers.length === 0) { htmlContent += '<p>Cargue un archivo para empezar.</p>'; this._div.innerHTML = htmlContent; return; } htmlContent += `<label>Capas (arrastra para ordenar):</label><ul id="layer-list" class="layer-list">`; orderedLayers.forEach(layer => { const layerId = L.stamp(layer); const isActiveClass = (currentActiveLayer && layerId === L.stamp(currentActiveLayer)) ? 'active' : ''; htmlContent += `<li class="${isActiveClass}" data-layer-id="${layerId}">${layer.options.config.name}</li>`; }); htmlContent += `</ul>`; if (currentActiveLayer) { const config = currentActiveLayer.options.config; htmlContent += `<div class="config-options">`; htmlContent += `<label for="mode-selector">Modo de Visualización:</label><select id="mode-selector">`; htmlContent += `<option value="simple" ${config.displayMode === 'simple' ? 'selected' : ''}>Estilo Simple</option>`; if (config.numericProperties.length > 0) { htmlContent += `<option value="classified" ${config.displayMode === 'classified' ? 'selected' : ''}>Clasificado (Números)</option>`; } if (config.stringProperties.length > 0) { htmlContent += `<option value="categorical" ${config.displayMode === 'categorical' ? 'selected' : ''}>Por Categorías (Texto)</option>`; } htmlContent += `</select>`; if (config.displayMode === 'simple') { htmlContent += `<label for="render-mode-selector">Mostrar:</label><select id="render-mode-selector"><option value="both" ${config.simpleRenderMode === 'both' ? 'selected' : ''}>Relleno y Contorno</option><option value="fill" ${config.simpleRenderMode === 'fill' ? 'selected' : ''}>Solo Relleno</option><option value="outline" ${config.simpleRenderMode === 'outline' ? 'selected' : ''}>Solo Contorno</option></select>`; htmlContent += `<div class="color-picker-container"><label>Relleno:</label><input type="color" id="fill-color-picker" value="${config.simpleFillColor}"></div>`; htmlContent += `<div class="color-picker-container"><label>Contorno:</label><input type="color" id="outline-color-picker" value="${config.simpleOutlineColor}"></div>`; } if (config.displayMode === 'classified') { htmlContent += `<label for="variable-selector">Variable Numérica:</label><select id="variable-selector">`; config.numericProperties.forEach(prop => { htmlContent += `<option value="${prop}" ${prop === config.activeVariable ? 'selected' : ''}>${prop}</option>`; }); htmlContent += `</select>`; htmlContent += `<label for="classes-input">Clases:</label><input type="number" id="classes-input" value="${config.numClasses}" min="2" max="10">`; htmlContent += `<label for="palette-selector">Paleta:</label><select id="palette-selector">`; for (const key in sequentialPalettes) { htmlContent += `<option value="${key}" ${key === config.activePalette ? 'selected' : ''}>${key}</option>`; } htmlContent += `</select>`; } if (config.displayMode === 'categorical') { htmlContent += `<label for="categorical-variable-selector">Variable de Texto:</label><select id="categorical-variable-selector">`; config.stringProperties.forEach(prop => { htmlContent += `<option value="${prop}" ${prop === config.activeCategoricalVariable ? 'selected' : ''}>${prop}</option>`; }); htmlContent += `</select>`; htmlContent += `<label for="categorical-palette-selector">Paleta:</label><select id="categorical-palette-selector">`; for (const key in categoricalPalettes) { htmlContent += `<option value="${key}" ${key === config.activeCategoricalPalette ? 'selected' : ''}>${key}</option>`; } htmlContent += `</select>`; } htmlContent += `</div>`; } this._div.innerHTML = htmlContent; const layerListEl = this._div.querySelector('#layer-list'); if (layerListEl) { sortableInstance = new Sortable(layerListEl, { animation: 150, onEnd: (evt) => { const movedItem = orderedLayers.splice(evt.oldIndex, 1)[0]; orderedLayers.splice(evt.newIndex, 0, movedItem); applyLayerOrder(); infoControl.update(); } }); } this._div.querySelectorAll('#layer-list li').forEach(item => { item.addEventListener('click', () => { const layerId = parseInt(item.dataset.layerId, 10); currentActiveLayer = orderedLayers.find(l => L.stamp(l) === layerId); this.update(); legendControl.update(currentActiveLayer); }); }); if (currentActiveLayer) { const config = currentActiveLayer.options.config; const modeSelector = this._div.querySelector('#mode-selector'); if (modeSelector) { modeSelector.onchange = (e) => { config.displayMode = e.target.value; this.update(); updateVisualization(currentActiveLayer); }; } if (config.displayMode === 'simple') { this._div.querySelector('#render-mode-selector').onchange = (e) => { config.simpleRenderMode = e.target.value; updateVisualization(currentActiveLayer); }; this._div.querySelector('#fill-color-picker').onchange = (e) => { config.simpleFillColor = e.target.value; updateVisualization(currentActiveLayer); }; this._div.querySelector('#outline-color-picker').onchange = (e) => { config.simpleOutlineColor = e.target.value; updateVisualization(currentActiveLayer); }; } if (config.displayMode === 'classified') { this._div.querySelector('#variable-selector').onchange = (e) => { config.activeVariable = e.target.value; updateVisualization(currentActiveLayer); }; this._div.querySelector('#classes-input').onchange = (e) => { let val = parseInt(e.target.value, 10); if (val >= 2 && val <= 10) { config.numClasses = val; updateVisualization(currentActiveLayer); } else { e.target.value = config.numClasses; } }; this._div.querySelector('#palette-selector').onchange = (e) => { config.activePalette = e.target.value; updateVisualization(currentActiveLayer); }; } if (config.displayMode === 'categorical') { this._div.querySelector('#categorical-variable-selector').onchange = (e) => { config.activeCategoricalVariable = e.target.value; updateVisualization(currentActiveLayer); }; this._div.querySelector('#categorical-palette-selector').onchange = (e) => { config.activeCategoricalPalette = e.target.value; updateVisualization(currentActiveLayer); }; } } };
    infoControl.addTo(map);
    legendControl.onAdd = function (map) { this._div = L.DomUtil.create('div', 'info legend'); return this._div; };
    legendControl.update = function (layer) { let content = ""; if (layer && layer.options.config.displayMode === 'classified' && layer.options.config.numericStats[layer.options.config.activeVariable].grades?.length > 1) { const config = layer.options.config; const grades = config.numericStats[config.activeVariable].grades; const palette = sequentialPalettes[config.activePalette]; let labels = ['<h4>' + config.activeVariable + '</h4>']; for (let i = 0; i < grades.length - 1; i++) { if (palette[i]) { labels.push(`<i style="background:${palette[i]}"></i> ${grades[i].toLocaleString(undefined, {maximumFractionDigits: 2})} &ndash; ${grades[i+1].toLocaleString(undefined, {maximumFractionDigits: 2})}`); } } content = labels.join('<br>'); } else if (layer && layer.options.config.displayMode === 'categorical' && layer.options.config.categoricalMap) { const config = layer.options.config; let labels = ['<h4>' + config.activeCategoricalVariable + '</h4>']; for (const value in config.categoricalMap) { labels.push(`<i style="background:${config.categoricalMap[value]}"></i> ${value}`); } content = labels.join('<br>'); } this._div.innerHTML = content; };
    legendControl.addTo(map);
    function applyLayerOrder() { orderedLayers.forEach(layer => layer.bringToFront()); }
    map.on('overlayadd', e => { const index = orderedLayers.findIndex(l => L.stamp(l) === L.stamp(e.layer)); if (index === -1) { orderedLayers.unshift(e.layer); } if (!currentActiveLayer) { currentActiveLayer = e.layer; } applyLayerOrder(); infoControl.update(); legendControl.update(currentActiveLayer); });
    map.on('overlayremove', e => { const layerIdToRemove = L.stamp(e.layer); orderedLayers = orderedLayers.filter(layer => L.stamp(layer) !== layerIdToRemove); if (e.layer === currentActiveLayer) { currentActiveLayer = orderedLayers.length > 0 ? orderedLayers[0] : null; } infoControl.update(); legendControl.update(currentActiveLayer); });
    function handleUploadedFile(file) {
        if (!file) return;
        const extension = file.name.split('.').pop().toLowerCase();
        const reader = new FileReader();

        const loadingMessage = L.DomUtil.create('div', 'loading-indicator', map.getContainer());
        loadingMessage.innerText = `Cargando ${file.name}...`;

        reader.onload = function(event) {
            try {
                if (extension === 'zip') {
                    shp(event.target.result).then(function(geojson){
                        processData(geojson, file.name);
                        map.getContainer().removeChild(loadingMessage);
                    }).catch(err => {
                        alert("Error procesando Shapefile: " + err.message);
                        map.getContainer().removeChild(loadingMessage);
                    });
                } else if (extension === 'geojson' || extension === 'json') {
                    processData(JSON.parse(event.target.result), file.name);
                    map.getContainer().removeChild(loadingMessage);
                }
            } catch (err) {
                alert("Error procesando el archivo: " + err.message);
                map.getContainer().removeChild(loadingMessage);
            }
        };
        reader.onerror = function() {
            alert("Error al leer el archivo.");
            map.getContainer().removeChild(loadingMessage);
        };

        if (extension === 'zip') {
            reader.readAsArrayBuffer(file);
        } else {
            reader.readAsText(file);
        }
    }
    
    L.Control.Custom = L.Control.extend({
        onAdd: function(map) {
            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control custom-control');
            container.innerText = 'Cargar Archivo(s)';
            const fileInput = L.DomUtil.create('input', 'hidden');
            fileInput.type = 'file'; fileInput.accept = ".geojson,.json,.zip"; fileInput.multiple = true;
            container.appendChild(fileInput);
            fileInput.onchange = (e) => { if (!e.target.files) return; for (const file of e.target.files) { handleUploadedFile(file); } e.target.value = ''; };
            L.DomEvent.on(container, 'click', (e) => { L.DomEvent.stopPropagation(e); fileInput.click(); });
            return container;
        }
    });
    new L.Control.Custom({ position: 'topleft' }).addTo(map);

    // --- FUNCIÓN EXPORTAR MAPA (USANDO LEAFLET-IMAGE) ---
    function exportMap() {
        const controlsToHide = document.querySelectorAll(
            '.leaflet-control-container > .leaflet-top, ' +
            '.leaflet-control-container > .leaflet-bottom-left, ' +
            '.info.leaflet-control'
        );
        controlsToHide.forEach(el => el.classList.add('hide-for-export'));

        leafletImage(map, function(err, canvas) {
            controlsToHide.forEach(el => el.classList.remove('hide-for-export'));
            if (err) {
                console.error("Error al exportar el mapa con leaflet-image:", err);
                alert("Hubo un error al exportar el mapa. Por favor, inténtelo de nuevo.");
            } else {
                const link = document.createElement('a');
                link.download = 'mapa_exportado.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            }
        });
    }

    L.Control.Export = L.Control.extend({
        onAdd: function(map) {
            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control custom-control');
            container.innerText = 'Exportar Imagen';
            L.DomEvent.on(container, 'click', function(e) { L.DomEvent.stopPropagation(e); exportMap(); });
            return container;
        }
    });
    new L.Control.Export({ position: 'topleft' }).addTo(map);

    // --- LÓGICA PARA LA HERRAMIENTA DE MEDICIÓN CON DESHACER (CTRL+Z) ---
    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    const drawControl = new L.Control.Draw({
        edit: {
            featureGroup: drawnItems,
            remove: true
        },
        draw: {
            polygon: {
                allowIntersection: false,
                showArea: true
            },
            polyline: true,
            rectangle: true,
            circle: false,
            marker: false
        }
    });
    map.addControl(drawControl);

    // Evento CUANDO SE DIBUJA ALGO
    map.on(L.Draw.Event.CREATED, function (e) {
        const layer = e.layer;
        const type = e.layerType;
        let content = '';

        if (type === 'polyline') {
            let distance = 0;
            const latlngs = layer.getLatLngs();
            for (let i = 0; i < latlngs.length - 1; i++) {
                distance += latlngs[i].distanceTo(latlngs[i+1]);
            }
            content = `Distancia: ${ (distance / 1000).toFixed(2) } km`;
        } else if (type === 'polygon' || type === 'rectangle') {
            const area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
            content = `Área: ${ (area / 10000).toFixed(2) } hectáreas`;
        }
        
        if (content) {
            layer.bindPopup(content).openPopup();
        }
        
        drawnItems.addLayer(layer);
        
        // ¡NUEVO! Añadir el elemento dibujado a la pila del historial
        drawnItemsHistory.push(layer); 
        console.log("Elemento dibujado añadido al historial. Historial actual:", drawnItemsHistory.length);
    });

    // --- Función para deshacer la última acción de dibujo ---
    function undoLastDrawAction() {
        if (drawnItemsHistory.length > 0) {
            const lastDrawnLayer = drawnItemsHistory.pop(); // Saca el último elemento de la pila
            if (drawnItems.hasLayer(lastDrawnLayer)) { // Verifica si el elemento aún está en el FeatureGroup
                drawnItems.removeLayer(lastDrawnLayer); // Elimina el elemento del FeatureGroup y del mapa
                console.log("Deshecha la última acción de dibujo. Elementos restantes:", drawnItemsHistory.length);
            } else {
                console.log("El último elemento ya no está en el mapa, o fue removido por otro medio.");
            }
        } else {
            console.log("No hay acciones de dibujo para deshacer.");
        }
    }

    // --- Event Listener para Ctrl+Z ---
    document.addEventListener('keydown', function(event) {
        // Verifica si Ctrl (Windows/Linux) o Command (Mac) están presionados, y la tecla 'z'
        const isCtrlOrCmdZ = (event.ctrlKey || event.metaKey) && event.key === 'z';

        // Solo actuamos si no estamos en un campo de texto para evitar deshacer texto
        // (aunque en este caso Leaflet.draw no tiene inputs de texto directo, es buena práctica)
        const isInputTarget = event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA';

        if (isCtrlOrCmdZ && !isInputTarget) {
            event.preventDefault(); // Evita el comportamiento predeterminado del navegador (ej. historial de navegación)
            undoLastDrawAction();
        }
    });

</script>

</body>
</html>
